#include<iostream>

template <typename T>
class Memory
{
private:
	size_t size = 0;
	T* memory = nullptr;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructor-------------------------------------------------------------------------------------------------------------------------------------------
public:
	Memory() {}	
	
	Memory(size_t in_size): size(in_size)
	{
		memory = new T [size];
	}
	
	Memory(size_t s, T* data) : size(s)				
	{
		memory = new T [s * s];
		
		for(size_t i = 0; i < s * s; i ++ )
			memory[i] = data[i];
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get_size----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const
	{
		return size;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--op=---------------------------------------------------------------------------------------------------------------------------------------------------	
	Memory& operator=(const Memory& rhs)
	{	
		std::cout << "op =" << '\n';
	
		if (this == &rhs) 
			return *this;
			
		size = rhs.size;	
			
		delete [] memory;
		memory = new T[size];
		
		std::copy(rhs.memory, rhs.memory + size, memory); 
		
		return *this;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-op=----------------------------------------------------------------------------------------------------------------------------------------------
	Memory& operator= (Memory&& rhs) 
	{	
		std::cout << "move-op=" << '\n';
		
		if (this == &rhs)
			return *this;
			
		std::swap(memory, rhs.memory);
		std::swap(size, rhs.size);
			
		return *this;
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--copy-constr-------------------------------------------------------------------------------------------------------------------------------------------
	Memory(const Memory& old) : size(old.size), memory(new T[size])
	{
		std::copy(old.memory, old.memory + size, memory); 
		std::cout << "copy-constr" << '\n';
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-copy-constr--------------------------------------------------------------------------------------------------------------------------------------
	Memory(Memory&& old) : size(old.size), memory(old.memory)  
	{
		std::cout << "move-copy-constr" << '\n';
		old.memory = nullptr;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------		
//--op[]-----------------------------------------------------------------------------------------------------------------------------------------	
	T& operator[](int x)
	{ 
		return *(memory + x);  
	}
	
	const T& operator[](int x) const 
	{ 
		return *(memory + x); 
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--destructor--------------------------------------------------------------------------------------------------------------------------------------------
	~Memory()
	{
		delete[] memory;
	}
};

//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------

template <typename T>
class Matrix 
{
	size_t m_size = 0;
	Memory<T> m_data;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructors------------------------------------------------------------------------------------------------------------------------------------------
public:	
	Matrix(size_t size) : m_size(size), m_data(Memory<T>{size * size}){}		//matrix with zero
	
	Matrix(size_t size, T* data) : m_size(size), m_data(Memory<T>{size * size, data}){}				//matrix with numbers
	
	Matrix(size_t size, Memory<T> data) : m_size(size), m_data(data){}	
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get-size-----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const
	{
		return m_size;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--print-function-----------------------------------------------------------------------------------------------------------------------------------------	
	bool print() const
	{
		for(size_t i = 0; i < m_size * m_size; i++)
		{
			std::cout<<m_data[i]<<' ';
			
			if((i + 1) % m_size == 0)
				std::cout<<std::endl;
		}
		
		return true;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--Pointer-for-[][]--------------------------------------------------------------------------------------------------------------------------------------
private:	
	class Pointer
	{
		int str ;
		Memory<T> &data;

	public:	
		Pointer(int str_plc, Memory<T> &dat) : str(str_plc), data(dat){}
		
		T& operator[](int y) 
		{ 
			return data[str + y]; 
		}
		
		const T& operator[](int y) const
		{ 
			return data[str + y]; 
		}
	};

public:	
	Pointer operator[](int x)
	{ 
		Pointer it{x * (int)m_size, m_data};
		return it;  
	}
	
	const Pointer operator[](int x) const 
	{ 
		const Pointer it{x * (int)m_size, const_cast<Memory<T>&>(m_data)};
		return it; 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--transpon---------------------------------------------------------------------------------------------------------------------------------------------
	Matrix transpon() const
	{
		//T* tran = new T[m_size * m_size];
		Memory<T> tran{m_size * m_size};
		
		for(size_t i = 0; i < m_size; i++)
			for(size_t j = 0; j < m_size; j++)
				tran[i * m_size + j]= (*this)[j][i];
				
		Matrix res{m_size, tran};
		
		return res;						//move-op= 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--deter------------------------------------------------------------------------------------------------------------------------------------------------
	T deter() const
	{
		Matrix help = *this;
		T k;
		T res = help[0][0];
		
		for(size_t i = 1; i < m_size; i++)
		{			
			for(size_t r = 0; r < i; r++)
			{
				k = help[i][r] / help[r][r];  
				
				for(size_t j = r; j < m_size; j++)
					help[i][j] = help[i][j] - k * help[r][j];
			}
			
			res = res * help[i][i];
			
			//std::cout << help[i][i] << std::endl;
		}			
		
		//help.print();	
		
		return res;	
	}

};

int main(void)
{
	Matrix<int> m{2};
	
	
	int x[4]  = {1, 2, 3, 4};

	Matrix<int> n{2, x};
	
	auto& a = n[1][1];
	
	m.print();
	n.print();
	
	std::cout << n[0][0] << ' ' <<n[0][1]<< ' ' << n[1][0] << ' ' << a << '\n';
	
	Matrix<int> f{n};
	f.print();
	
	m = n;
	
	m.print();
	n.print();
	
	f = m.transpon();
	
	f.print();
	
	int y[9]  = {1, 2, 3, 4, 5, 6, 7, 8, 10};
	
	Matrix<int> mat{3, y};
	
	int res = mat.deter();
	
	std::cout << res << std::endl;
}
