#include<iostream>

//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------
template <typename T>
class Matrix 
{
	int m_size = 0;
	T *m_data;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructors------------------------------------------------------------------------------------------------------------------------------------------
public:	
	Matrix(int size) : m_size(size)			//matrix with zero
	{
		m_data = new T [size * size];		
	}
	
	Matrix(int size, T* data) : m_size(size)		//matrix with numbes
	{
		m_data = new T [size * size];
		
		for(int i = 0; i < size * size; i ++ )
			m_data[i] = data[i];
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--copy-constructor---------------------------------------------------------------------------------------------------------------------------------------
	Matrix(const Matrix& old) : m_size(old.m_size), m_data(new int[m_size * m_size]) 
	{
		std::copy(old.m_data, old.m_data + m_size * m_size, m_data); //оно зануляет оба массива почему???
		
		/*for(int i = 0; i < m_size * m_size; i ++ )
			m_data[i] = old.m_data[i];*/
		
		std::cout << "copy-constr" << '\n';
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--copy-move----------------------------------------------------------------------------------------------------------------------------------------------	
	Matrix(Matrix&& old) : m_size(old.m_size), m_data(old.m_data)  
	{
		old.m_data = nullptr;
		
		std::cout << "move-copy-constr" << '\n';
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--operator=----------------------------------------------------------------------------------------------------------------------------------------------
	Matrix& operator= (const Matrix& rhs) 
	{
		std::cout << "op =" << '\n';
	
		if (this == &rhs) 
			return *this;
		m_size = rhs.m_size;
		delete [] m_data;
		m_data = new T[m_size * m_size];
		//std::copy(m_data, m_data + m_size * m_size, rhs.m_data);
		
		for(int i = 0; i < m_size * m_size; i ++ )
			m_data[i] = rhs.m_data[i];
		
		return *this;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------		
//--move-operator=-----------------------------------------------------------------------------------------------------------------------------------------
	Matrix& operator= (Matrix&& rhs) 
	{
		std::cout << "move-op=" << '\n';
	
		if (this == &rhs)
			return *this;
			
		std::swap(m_data, rhs.m_data);
		std::swap(m_size, rhs.m_size);
			
		return *this;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--print-function-----------------------------------------------------------------------------------------------------------------------------------------	
	bool print() const
	{
		for(int i = 0; i < m_size * m_size; i++)
		{
			std::cout<<m_data[i]<<' ';
			
			if((i + 1) % m_size == 0)
				std::cout<<std::endl;
		}
		
		return true;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--Iterator-for-[][]--------------------------------------------------------------------------------------------------------------------------------------
private:	
	class Iterator
	{
	
	
		T* pointer;
	public:	
		Iterator(T* it) : pointer(it) {}
		
		T& operator[](int y) 
		{ 
			return *(pointer + y); 
		}
		
		const T& operator[](int y) const
		{ 
			return *(pointer + y); 
		}
	};

public:	
	Iterator operator[](int x) 
	{ 
		Iterator it{m_data + x * m_size};
		return it;  
	}
	
	const Iterator operator[](int x) const 
	{ 
		const Iterator it{m_data + x * m_size};
		return it; 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--transpon---------------------------------------------------------------------------------------------------------------------------------------------
	Matrix transpon() const
	{
		T* tran = new T[m_size * m_size];
		
		for(int i = 0; i < m_size; i++)
			for(int j = 0; j < m_size; j++)
				tran[i * m_size + j]= (*this)[j][i];
				
		Matrix res{m_size, tran};
		
		return res;						//move-op= save situation
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--deter------------------------------------------------------------------------------------------------------------------------------------------------
	T deter() const
	{
		Matrix help = *this;
		T k;
		T res = help[0][0];
		
		for(int i = 1; i < m_size; i++)
		{			
			for(int r = 0; r < i; r++)
			{
				k = help[i][r] / help[r][r];  
				
				for(int j = r; j < m_size; j++)
					help[i][j] = help[i][j] - k * help[r][j];
			}
			
			res = res * help[i][i];
			
			//std::cout << help[i][i] << std::endl;
		}			
		
		//help.print();	
		
		return res;	
	}
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--negate-----------------------------------------------------------------------------------------------------------------------------------------------
	Matrix negate() const
	{
	
	}
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--destructor-------------------------------------------------------------------------------------------------------------------------------------------	
	~Matrix()
	{
		delete[] m_data;
	}
};

int main(void)
{
	Matrix<int> m{2};
	
	
	int x[4]  = {1, 2, 3, 4};

	Matrix<int> n{2, x};
	
	auto& a = n[1][1];
	
	m.print();
	n.print();
	
	std::cout << n[0][0] << ' ' <<n[0][1]<< ' ' << n[1][0] << ' ' << a << '\n';
	
	Matrix<int> f{n};
	f.print();
	
	m = n;
	
	m.print();
	n.print();
	
	f = m.transpon();
	
	f.print();
	
	int y[9]  = {1, 2, 3, 4, 5, 6, 7, 8, 10};
	
	Matrix<int> mat{3, y};
	
	int res = mat.deter();
	
	std::cout << res << std::endl;
}
