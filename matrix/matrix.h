#include<iostream>

namespace my
{
	template <typename T>
	T *safe_copy(const T* src, size_t srcsize)
	{
		T *dest = new T[srcsize];
		try
		{
			for(size_t idx = 0; idx != srcsize; ++idx)
				dest[idx] = src[idx];
		}
		catch(...)
		{
			delete[] dest;
			throw;
		}
		return dest;
	}
}

template <typename T>
class Memory
{
private:
	size_t size = 0;
	T* memory = nullptr;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructor-------------------------------------------------------------------------------------------------------------------------------------------
public:
	Memory() {}	
	
	Memory(size_t in_size): size(in_size), memory(new T [size]) {}
	
	Memory(size_t s, T* data) : size(s)				
	{	
		try
		{		
			memory = my::safe_copy<T>(data, s); 
		}
		
		catch(...)
		{ 
			size = 0;
		}
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get_size----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const
	{
		return size;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--swap--------------------------------------------------------------------------------------------------------------------------------------------------
	void swap(Memory<T>& rhs) noexcept
	{
		std::swap(memory, rhs.memory);
		std::swap(size, rhs.size);
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-op=----------------------------------------------------------------------------------------------------------------------------------------------
	Memory& operator= (Memory&& rhs) noexcept
	{	
		//std::cout << "move-op=" << '\n';
		
		if (this == &rhs)
			return *this;
			
		std::swap(memory, rhs.memory);
		std::swap(size, rhs.size);
			
		return *this;
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--copy-constr-------------------------------------------------------------------------------------------------------------------------------------------
	Memory(const Memory& old) : size(old.size)
	{
		memory = my::safe_copy<T>(old.memory, size); 
		//std::cout << "copy-constr" << '\n';
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-copy-constr--------------------------------------------------------------------------------------------------------------------------------------
	Memory(Memory&& old) noexcept : size(old.size), memory(old.memory)
	{
		//std::cout << "move-copy-constr" << '\n';
		old.memory = nullptr;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--op=---------------------------------------------------------------------------------------------------------------------------------------------------	
	Memory operator=(const Memory& rhs)
	{	
		std::cout << "op =" << '\n';
		
		Memory<T> res{rhs};
		swap(res); 
			 
		return  *this;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------		
//--op[]-----------------------------------------------------------------------------------------------------------------------------------------	
	T& operator[](int x)
	{ 
		if (x < 0 || size <= x) throw std::out_of_range{"Memory::operator[]"};
		
		return memory[x];  
	}
	
	const T& operator[](int x) const 
	{ 
		if (x < 0 || size <= x) throw std::out_of_range{"Memory::operator[]"};
		
		return memory[x]; 
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--destructor--------------------------------------------------------------------------------------------------------------------------------------------
	~Memory()
	{
		delete[] memory;
	}
};

//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------

template <typename T>
class Matrix 
{
	size_t m_size = 0;
	Memory<T> m_data;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructors------------------------------------------------------------------------------------------------------------------------------------------
public:	
	Matrix(size_t size) : m_size(size), m_data(Memory<T>{size * size}){}						//matrix with zero
	
	Matrix(size_t size, T* data) : m_size(size), m_data(Memory<T>{size * size, data}){}				//matrix with numbers
	
	Matrix(size_t size, Memory<T> data) : m_size(size), m_data(data){}						//it may die
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get-size-----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const noexcept
	{
		return m_size;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--print-function-----------------------------------------------------------------------------------------------------------------------------------------	
	void print() const
	{
		for(size_t i = 0; i < m_size * m_size; i++)
		{
			std::cout<<m_data[i]<<' ';
			
			if((i + 1) % m_size == 0)
				std::cout<<std::endl;
		}
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--Pointer-for-[][]--------------------------------------------------------------------------------------------------------------------------------------
private:	
	class Pointer
	{
		int str ;
		Memory<T> &data;
		int size;

	public:	
		Pointer(int str_plc, Memory<T> &dat, int s) : str(str_plc), data(dat), size(s){}
		
		T& operator[](int y) 
		{ 
			if (y < 0 || size <= y) throw std::out_of_range{"Matrix::operator[][]"};
			
			return data[str + y]; 
		}
		
		const T& operator[](int y) const
		{ 
			if (y < 0 || size <= y) throw std::out_of_range{"Matrix::operator[][]"};
			
			return data[str + y]; 
		}
	};

public:	
	Pointer operator[](int x)
	{ 
		if (x < 0 || m_size <= x) throw std::out_of_range{"Matrix::operator[][]"};
		
		Pointer it{x * (int)m_size, m_data, (int)m_size};
		return it;  
	}
	
	const Pointer operator[](int x) const 
	{ 
		if (x < 0 || m_size <= x) throw std::out_of_range{"Matrix::operator[][]"};
		
		const Pointer it{x * (int)m_size, const_cast<Memory<T>&>(m_data), (int)m_size};
		return it; 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--transpon---------------------------------------------------------------------------------------------------------------------------------------------
	Matrix transpon() const
	{
		Memory<T> tran{m_size * m_size};
		
		for(size_t i = 0; i < m_size; i++)
			for(size_t j = 0; j < m_size; j++)
				tran[i * m_size + j]= (*this)[j][i];
				
		Matrix res{m_size, tran};
		
		return res;						//move-op= 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--deter------------------------------------------------------------------------------------------------------------------------------------------------
	double deter() const
	{
		Matrix<double> help = *this;
		double k;
		
		double res = (double)help[0][0];
		
		for(size_t i = 1; i < m_size; i++)
		{		
			//std::cout << help[2][2] << std::endl;	
			for(size_t r = 0; r < i; r++)
			{
				if(help[r][r] == 0)
				{	
					size_t l = 0;
				
					while(help[l][r] == 0)
					{
						l++;
						if(l == m_size)
							return 0;
					}
				
					for(size_t j = 0; j < m_size; j++)
						help[r][j] = help[r][j] + help[l][j];								
				}

				k = help[i][r] / help[r][r];  
				
				for(size_t j = r; j < m_size; j++)
					help[i][j] = help[i][j] - k * help[r][j];
			}
			
			res = res * help[i][i];
			
			//std::cout << help[i][i] << std::endl;
		}			
		
		//help.print();	
		
		return res;	
	}

};


