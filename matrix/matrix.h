#include<iostream>

template <typename T>
class Memory
{
private:
	size_t size = 0;
	T* memory = nullptr;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructor-------------------------------------------------------------------------------------------------------------------------------------------
public:
	Memory() {}	
	
	Memory(size_t in_size): size(in_size)
	{
		memory = new T [size];
	}
	
	Memory(size_t s, T* data) : size(s)				
	{
		memory = new T [s];
		
		try
		{
			for(size_t i = 0; i < s; i ++ )
				memory[i] = data[i];
		}
		
		catch(...)
		{ 
			delete[] memory;
			size = 0;
			throw;
		}
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get_size----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const
	{
		return size;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--op=---------------------------------------------------------------------------------------------------------------------------------------------------	
	Memory& operator=(const Memory& rhs)
	{	
		//std::cout << "op =" << '\n';
	
		if (this == &rhs) 
			return *this;
			
		size = rhs.size;	
			
		delete [] memory;
		memory = new T[size];
		
		std::copy(rhs.memory, rhs.memory + size, memory); 
		
		return *this;
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-op=----------------------------------------------------------------------------------------------------------------------------------------------
	Memory& operator= (Memory&& rhs) noexcept
	{	
		//std::cout << "move-op=" << '\n';
		
		if (this == &rhs)
			return *this;
			
		std::swap(memory, rhs.memory);
		std::swap(size, rhs.size);
			
		return *this;
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--copy-constr-------------------------------------------------------------------------------------------------------------------------------------------
	Memory(const Memory& old) : size(old.size), memory(new T[size]) 
	{
		std::copy(old.memory, old.memory + size, memory); 
		//std::cout << "copy-constr" << '\n';
	}
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--move-copy-constr--------------------------------------------------------------------------------------------------------------------------------------
	Memory(Memory&& old) noexcept : size(old.size), memory(old.memory)
	{
		//std::cout << "move-copy-constr" << '\n';
		old.memory = nullptr;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------		
//--op[]-----------------------------------------------------------------------------------------------------------------------------------------	
	T& operator[](int x)
	{ 
		if (x < 0 || size <= x) throw std::out_of_range{"Memory::operator[]"};
		
		return *(memory + x);  
	}
	
	const T& operator[](int x) const 
	{ 
		if (x < 0 || size <= x) throw std::out_of_range{"Memory::operator[]"};
		
		return *(memory + x); 
	}	
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--destructor--------------------------------------------------------------------------------------------------------------------------------------------
	~Memory()
	{
		delete[] memory;
	}
};

//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------

template <typename T>
class Matrix 
{
	size_t m_size = 0;
	Memory<T> m_data;
//--------------------------------------------------------------------------------------------------------------------------------------------------------	
//--constructors------------------------------------------------------------------------------------------------------------------------------------------
public:	
	Matrix(size_t size) : m_size(size), m_data(Memory<T>{size * size}){}						//matrix with zero
	
	Matrix(size_t size, T* data) : m_size(size), m_data(Memory<T>{size * size, data}){}				//matrix with numbers
	
	Matrix(size_t size, Memory<T> data) : m_size(size), m_data(data){}						//it may die
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--get-size-----------------------------------------------------------------------------------------------------------------------------------------------
	size_t get_size() const noexcept
	{
		return m_size;
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--print-function-----------------------------------------------------------------------------------------------------------------------------------------	
	void print() const noexcept
	{
		for(size_t i = 0; i < m_size * m_size; i++)
		{
			std::cout<<m_data[i]<<' ';
			
			if((i + 1) % m_size == 0)
				std::cout<<std::endl;
		}
	}
//---------------------------------------------------------------------------------------------------------------------------------------------------------	
//--Pointer-for-[][]--------------------------------------------------------------------------------------------------------------------------------------
private:	
	class Pointer
	{
		int str ;
		Memory<T> &data;
		int size;

	public:	
		Pointer(int str_plc, Memory<T> &dat, int s) : str(str_plc), data(dat), size(s){}
		
		T& operator[](int y) 
		{ 
			if (y < 0 || size <= y) throw std::out_of_range{"Matrix::operator[][]"};
			
			return data[str + y]; 
		}
		
		const T& operator[](int y) const
		{ 
			if (y < 0 || size <= y) throw std::out_of_range{"Matrix::operator[][]"};
			
			return data[str + y]; 
		}
	};

public:	
	Pointer operator[](int x)
	{ 
		if (x < 0 || m_size <= x) throw std::out_of_range{"Matrix::operator[][]"};
		
		Pointer it{x * (int)m_size, m_data, (int)m_size};
		return it;  
	}
	
	const Pointer operator[](int x) const 
	{ 
		if (x < 0 || m_size <= x) throw std::out_of_range{"Matrix::operator[][]"};
		
		const Pointer it{x * (int)m_size, const_cast<Memory<T>&>(m_data), (int)m_size};
		return it; 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--transpon---------------------------------------------------------------------------------------------------------------------------------------------
	Matrix transpon() const
	{
		Memory<T> tran{m_size * m_size};
		
		for(size_t i = 0; i < m_size; i++)
			for(size_t j = 0; j < m_size; j++)
				tran[i * m_size + j]= (*this)[j][i];
				
		Matrix res{m_size, tran};
		
		return res;						//move-op= 
	}	
//-------------------------------------------------------------------------------------------------------------------------------------------------------	
//--deter------------------------------------------------------------------------------------------------------------------------------------------------
	T deter() const
	{
		Matrix help = *this;
		T k;
		
		for(size_t i = 0; i < m_size; i++)
		{
			if(help[i][i] == 0)
			{	
				size_t l = 0;
				
				while(help[l][i] == 0)
				{
					l++;
					if(l == m_size)
						return 0;
				}
				
				for(size_t j = 0; j < m_size; j++)
					help[i][j] = help[i][j] + help[l][j];
								
			}
		}
		
		T res = help[0][0];
		
		for(size_t i = 1; i < m_size; i++)
		{			
			for(size_t r = 0; r < i; r++)
			{
				k = help[i][r] / help[r][r];  
				
				for(size_t j = r; j < m_size; j++)
					help[i][j] = help[i][j] - k * help[r][j];
			}
			
			res = res * help[i][i];
			
			//std::cout << help[i][i] << std::endl;
		}			
		
		//help.print();	
		
		return res;	
	}

};


